# 裸机代码移植到uC/OS-III完整指南

**文档日期**: 2026-02-14  
**适用对象**: IIC通信 + MPU6050驱动移植  
**目标系统**: STM32F4 + uC/OS-III

---

## 📚 目录

1. [移植概述](#移植概述)
2. [IIC驱动移植](#iic驱动移植)
3. [MPU6050驱动移植](#mpu6050驱动移植)
4. [任务设计](#任务设计)
5. [集成到现有项目](#集成到现有项目)
6. [测试验证](#测试验证)
7. [常见问题](#常见问题)

---

## 移植概述

### 核心思想

**裸机代码的问题**：
- 使用 `while(i--)` 死等延时 → 阻塞整个系统
- 直接操作硬件无保护 → 多任务冲突
- 中断中处理复杂逻辑 → 影响实时性

**RTOS代码的要求**：
- 使用 `OSTimeDly()` 让出CPU → 其他任务可运行
- 使用互斥锁保护共享资源 → 线程安全
- 中断只做必要操作，通知任务处理 → 提高实时性

### 移植三原则

1. **互斥保护**：所有共享资源（IIC总线、全局变量）必须用互斥锁保护
2. **延时替换**：所有 `delay_ms()` 改为 `OSTimeDly()`
3. **任务化设计**：初始化、数据读取、数据处理分离到不同任务

---

## IIC驱动移植

### 步骤1：分析裸机代码

**典型裸机IIC代码**：
```c
// 裸机版本（错误示例）
void IIC_Delay(void)
{
    uint8_t i = 10;
    while(i--);  // ❌ 阻塞整个系统！
}

void IIC_Write_Byte(uint8_t addr, uint8_t data)
{
    IIC_Start();
    IIC_Send_Byte(addr);
    IIC_Wait_Ack();
    IIC_Send_Byte(data);
    IIC_Wait_Ack();
    IIC_Stop();
}
```

**问题分析**：
1. `while(i--)` 死等延时 → 其他任务无法运行
2. 无互斥锁保护 → 多个任务同时调用会冲突
3. 无错误处理 → IIC通信失败无法恢复

### 步骤2：添加RTOS支持

**RTOS版本（正确做法）**：
```c
// 全局互斥锁
OS_MUTEX IIC_Mutex;

// 初始化时创建互斥锁
void IIC_Init(void)
{
    OS_ERR err;
    IIC_GPIO_Config();
    OSMutexCreate(&IIC_Mutex, "IIC Mutex", &err);
}

// 延时函数（RTOS版本）
void IIC_Delay(void)
{
    // 方案1：高速IIC（400kHz），使用空循环
    volatile uint16_t i = 84;
    while(i--);
    
    // 方案2：低速IIC（100kHz），使用RTOS延时
    // OS_ERR err;
    // OSTimeDlyHMSM(0, 0, 0, 1, OS_OPT_TIME_HMSM_STRICT, &err);
}

// 线程安全的写函数
uint8_t IIC_Write_Byte(uint8_t dev_addr, uint8_t reg_addr, uint8_t data)
{
    OS_ERR err;
    uint8_t result;
    
    // 获取互斥锁
    OSMutexPend(&IIC_Mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);
    
    // IIC操作
    IIC_Start();
    IIC_Send_Byte((dev_addr << 1) | 0);
    if(IIC_Wait_Ack()) { result = 1; goto exit; }
    
    IIC_Send_Byte(reg_addr);
    if(IIC_Wait_Ack()) { result = 1; goto exit; }
    
    IIC_Send_Byte(data);
    if(IIC_Wait_Ack()) { result = 1; goto exit; }
    
    result = 0;
    
exit:
    IIC_Stop();
    OSMutexPost(&IIC_Mutex, OS_OPT_POST_NONE, &err);
    return result;
}
```

### 步骤3：关键点说明

| 项目 | 裸机版本 | RTOS版本 | 原因 |
|------|---------|---------|------|
| 延时 | `while(i--)` | `volatile while(i--)` 或 `OSTimeDly()` | 防止编译器优化，或让出CPU |
| 互斥保护 | 无 | `OSMutexPend/Post` | 防止多任务冲突 |
| 错误处理 | 无 | 返回错误码 | 便于任务层处理 |
| 初始化 | `main()`中 | 任务中 | RTOS对象需在任务中创建 |

---

## MPU6050驱动移植

### 步骤1：理解MPU6050工作流程

```
初始化流程：
1. 检查WHO_AM_I（0x75）→ 应返回0x68
2. 复位设备（PWR_MGMT_1 = 0x80）
3. 唤醒设备（PWR_MGMT_1 = 0x00）
4. 配置采样率、滤波器、量程

数据读取流程：
1. 读取14字节（0x3B~0x48）
2. 解析为加速度、温度、陀螺仪数据
3. 转换为物理单位（g, °/s, °C）
```

### 步骤2：数据结构设计

```c
// 原始数据（16位整数）
typedef struct
{
    int16_t accel_x, accel_y, accel_z;
    int16_t temp;
    int16_t gyro_x, gyro_y, gyro_z;
} MPU6050_RawData_t;

// 处理后数据（浮点数）
typedef struct
{
    float accel_x, accel_y, accel_z;  // 单位：g
    float temp;                        // 单位：°C
    float gyro_x, gyro_y, gyro_z;      // 单位：°/s
} MPU6050_Data_t;

// 姿态数据
typedef struct
{
    float roll, pitch, yaw;  // 单位：°
} MPU6050_Attitude_t;
```

### 步骤3：同步对象设计

```c
OS_MUTEX MPU6050_Mutex;           // 保护全局数据
OS_SEM   MPU6050_Data_Ready_Sem;  // 通知新数据就绪
OS_Q     MPU6050_Data_Queue;      // 数据队列（可选）
```

**使用场景**：

| 同步对象 | 使用场景 | 优点 | 缺点 |
|---------|---------|------|------|
| 互斥锁 | 保护全局变量 | 简单直接 | 需要主动获取 |
| 信号量 | 通知数据更新 | 高效 | 只能传递信号 |
| 消息队列 | 传递数据副本 | 解耦任务 | 占用内存 |

### 步骤4：初始化函数移植

**裸机版本**：
```c
void MPU6050_Init(void)
{
    IIC_Write_Byte(0x68, 0x6B, 0x80);  // 复位
    delay_ms(100);                      // ❌ 阻塞延时
    IIC_Write_Byte(0x68, 0x6B, 0x00);  // 唤醒
}
```

**RTOS版本**：
```c
uint8_t MPU6050_Init(void)
{
    OS_ERR err;
    uint8_t who_am_i;
    
    // 创建同步对象
    OSMutexCreate(&MPU6050_Mutex, "MPU6050 Mutex", &err);
    OSSemCreate(&MPU6050_Data_Ready_Sem, "Data Ready", 0, &err);
    
    // 检查设备
    if(MPU6050_Read_Reg(0x75, &who_am_i) != 0)
        return 1;
    if(who_am_i != 0x68)
        return 1;
    
    // 复位
    MPU6050_Write_Reg(0x6B, 0x80);
    OSTimeDly(100, OS_OPT_TIME_DLY, &err);  // ✓ RTOS延时
    
    // 唤醒
    MPU6050_Write_Reg(0x6B, 0x00);
    OSTimeDly(10, OS_OPT_TIME_DLY, &err);
    
    // 配置...
    
    return 0;
}
```

---

## 任务设计

### 方案1：单任务模式（简单）

```c
void Task_MPU6050(void *p_arg)
{
    OS_ERR err;
    MPU6050_RawData_t raw;
    MPU6050_Data_t data;
    
    // 初始化
    OSTimeDly(200, OS_OPT_TIME_DLY, &err);
    MPU6050_Init();
    
    while(1)
    {
        // 读取数据
        MPU6050_Read_Raw_Data(&raw);
        
        // 处理数据
        MPU6050_Process_Data(&raw, &data);
        
        // 显示数据
        printf("Accel: %.2f, %.2f, %.2f\r\n", 
               data.accel_x, data.accel_y, data.accel_z);
        
        // 延时
        OSTimeDly(10, OS_OPT_TIME_DLY, &err);
    }
}
```

**优点**：简单，适合学习  
**缺点**：读取、处理、显示耦合在一起

### 方案2：双任务模式（推荐）

```c
// 任务1：读取数据
void Task_MPU6050_Read(void *p_arg)
{
    OS_ERR err;
    MPU6050_RawData_t raw;
    MPU6050_Data_t data;
    
    MPU6050_Init();
    
    while(1)
    {
        // 读取原始数据
        if(MPU6050_Read_Raw_Data(&raw) == 0)
        {
            // 处理数据
            MPU6050_Process_Data(&raw, &data);
            
            // 更新全局变量（互斥锁保护）
            OSMutexPend(&MPU6050_Mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);
            g_mpu6050_data = data;
            OSMutexPost(&MPU6050_Mutex, OS_OPT_POST_NONE, &err);
            
            // 通知数据就绪
            OSSemPost(&MPU6050_Data_Ready_Sem, OS_OPT_POST_1, &err);
        }
        
        OSTimeDly(10, OS_OPT_TIME_DLY, &err);  // 100Hz
    }
}

// 任务2：显示数据
void Task_MPU6050_Display(void *p_arg)
{
    OS_ERR err;
    MPU6050_Data_t data;
    
    while(1)
    {
        // 等待新数据
        OSSemPend(&MPU6050_Data_Ready_Sem, 1000, OS_OPT_PEND_BLOCKING, NULL, &err);
        
        if(err == OS_ERR_NONE)
        {
            // 获取数据
            OSMutexPend(&MPU6050_Mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);
            data = g_mpu6050_data;
            OSMutexPost(&MPU6050_Mutex, OS_OPT_POST_NONE, &err);
            
            // 显示
            printf("Accel: %.2f, %.2f, %.2f\r\n", 
                   data.accel_x, data.accel_y, data.accel_z);
        }
    }
}
```

**优点**：读取和显示解耦，显示任务不影响读取周期  
**缺点**：代码量增加

### 任务优先级建议

| 任务 | 优先级 | 周期 | 说明 |
|------|-------|------|------|
| Task_MPU6050_Read | 10（中） | 10ms | 保证数据采集实时性 |
| Task_MPU6050_Display | 15（低） | 按需 | 显示不影响采集 |
| Task_Attitude_Calc | 12（中低） | 20ms | 姿态解算 |
| Task_LCD_Display | 20（最低） | 50ms | LCD刷新 |

---

## 集成到现有项目

### 步骤1：添加文件到项目

1. 复制文件到项目目录：
   ```
   D:\STM32\code-re\示例-学习\uC-OS3-time\study\
   ├── iic_rtos_guide.c
   └── mpu6050_rtos.c
   ```

2. 在Keil中添加文件：
   - 右键项目 → Add Existing Files to Group
   - 选择 `iic_rtos_guide.c` 和 `mpu6050_rtos.c`

### 步骤2：修改 bsp.c

```c
#include "bsp.h"
#include "./LED/led.h"
#include "./usart/usart.h"
#include "./key/key.h"
#include "./exti/exti.h"
#include "./lcd/lcd.h"
#include "./lcd/lcd_init.h"
#include "./delay/delay.h"
#include "../study/iic_rtos_guide.c"  // 添加

void bsp_init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
    delay_init(168);
    lcd_config();
    exti_config();
    led_init();
    usart_config();
    KEY_Init();
    IIC_Init();  // 添加IIC初始化
}
```

### 步骤3：修改 task.c

```c
#include "../study/mpu6050_rtos.c"  // 添加

/* 定义MPU6050任务 */
#define MPU6050_READ_PRIO       10
#define MPU6050_READ_STK_SIZE   1024
OS_TCB      MPU6050_Read_TCB;
CPU_STK     MPU6050_Read_STK[MPU6050_READ_STK_SIZE];

#define MPU6050_DISPLAY_PRIO    15
#define MPU6050_DISPLAY_STK_SIZE 512
OS_TCB      MPU6050_Display_TCB;
CPU_STK     MPU6050_Display_STK[MPU6050_DISPLAY_STK_SIZE];

void start_task(void *p_arg)
{
    OS_ERR err;
    // ... 原有代码 ...
    
    /* 创建MPU6050读取任务 */
    OSTaskCreate(&MPU6050_Read_TCB, "MPU6050_Read", Task_MPU6050_Read, NULL,
                 MPU6050_READ_PRIO,
                 &MPU6050_Read_STK[0],
                 MPU6050_READ_STK_SIZE / 10,
                 MPU6050_READ_STK_SIZE,
                 0, 0, NULL,
                 OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR,
                 &err);
    
    /* 创建MPU6050显示任务 */
    OSTaskCreate(&MPU6050_Display_TCB, "MPU6050_Display", Task_MPU6050_Display, NULL,
                 MPU6050_DISPLAY_PRIO,
                 &MPU6050_Display_STK[0],
                 MPU6050_DISPLAY_STK_SIZE / 10,
                 MPU6050_DISPLAY_STK_SIZE,
                 0, 0, NULL,
                 OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR,
                 &err);
    
    OSTaskDel(NULL, &err);
}
```

### 步骤4：配置IIC引脚

在 `iic_rtos_guide.c` 中修改引脚定义：

```c
/* 根据实际硬件修改 */
#define IIC_SCL_GPIO_PORT       GPIOB
#define IIC_SCL_GPIO_PIN        GPIO_Pin_8
#define IIC_SDA_GPIO_PORT       GPIOB
#define IIC_SDA_GPIO_PIN        GPIO_Pin_9
```

---

## 测试验证

### 测试1：IIC通信测试

```c
void Task_IIC_Test(void *p_arg)
{
    OS_ERR err;
    uint8_t who_am_i;
    
    OSTimeDly(200, OS_OPT_TIME_DLY, &err);
    
    // 读取WHO_AM_I寄存器
    if(IIC_Read_Byte(0x68, 0x75, &who_am_i) == 0)
    {
        printf("WHO_AM_I = 0x%02X\r\n", who_am_i);
        if(who_am_i == 0x68)
            printf("MPU6050 detected!\r\n");
        else
            printf("Unknown device!\r\n");
    }
    else
    {
        printf("IIC communication failed!\r\n");
    }
    
    OSTaskDel(NULL, &err);
}
```

### 测试2：数据读取测试

```c
void Task_MPU6050_Test(void *p_arg)
{
    OS_ERR err;
    MPU6050_Data_t data;
    uint32_t count = 0;
    
    OSTimeDly(200, OS_OPT_TIME_DLY, &err);
    
    if(MPU6050_Init() != 0)
    {
        printf("MPU6050 init failed!\r\n");
        OSTaskDel(NULL, &err);
        return;
    }
    
    while(count < 10)  // 读取10次
    {
        if(MPU6050_Get_Data(&data) == 0)
        {
            printf("[%lu] Accel: %.2f, %.2f, %.2f g\r\n", 
                   count, data.accel_x, data.accel_y, data.accel_z);
            count++;
        }
        OSTimeDly(100, OS_OPT_TIME_DLY, &err);
    }
    
    printf("Test completed!\r\n");
    OSTaskDel(NULL, &err);
}
```

### 测试3：LCD显示测试

```c
void Task_MPU6050_LCD_Test(void *p_arg)
{
    OS_ERR err;
    MPU6050_Data_t data;
    MPU6050_Attitude_t attitude;
    char buf[32];
    
    OSTimeDly(300, OS_OPT_TIME_DLY, &err);
    
    LCD_Fill(0, 0, LCD_HEIGHT, LCD_WIDTH, WHITE);
    LCD_ShowString(0, 0, "MPU6050 Test", BLACK, WHITE, 16, 0);
    
    while(1)
    {
        OSSemPend(&MPU6050_Data_Ready_Sem, 1000, OS_OPT_PEND_BLOCKING, NULL, &err);
        
        if(err == OS_ERR_NONE && MPU6050_Get_Data(&data) == 0)
        {
            MPU6050_Calculate_Attitude(&data, &attitude);
            
            sprintf(buf, "Roll: %6.1f", attitude.roll);
            LCD_ShowString(0, 20, (u8*)buf, BLACK, WHITE, 16, 0);
            
            sprintf(buf, "Pitch:%6.1f", attitude.pitch);
            LCD_ShowString(0, 40, (u8*)buf, BLACK, WHITE, 16, 0);
            
            sprintf(buf, "Temp: %6.1fC", data.temp);
            LCD_ShowString(0, 60, (u8*)buf, BLACK, WHITE, 16, 0);
        }
    }
}
```

---

## 常见问题

### 问题1：WHO_AM_I读取失败

**现象**：
```
IIC communication failed!
```

**可能原因**：
1. IIC引脚定义错误
2. 没有上拉电阻（需要4.7kΩ）
3. MPU6050供电不足
4. IIC时序不正确

**解决方法**：
```c
// 1. 检查引脚定义
#define IIC_SCL_GPIO_PIN  GPIO_Pin_8  // 确认是否正确

// 2. 使用万用表测量
// - SCL和SDA是否有3.3V（上拉电阻）
// - VCC是否有3.3V

// 3. 使用逻辑分析仪查看波形
// - 起始条件是否正确
// - ACK信号是否正常
```

### 问题2：数据全为0或异常值

**现象**：
```
Accel: 0.00, 0.00, 0.00 g
```

**可能原因**：
1. MPU6050未正确初始化
2. 寄存器配置错误
3. 数据解析错误

**解决方法**：
```c
// 1. 检查初始化返回值
if(MPU6050_Init() != 0)
{
    printf("Init failed!\r\n");
}

// 2. 读取配置寄存器验证
uint8_t config;
MPU6050_Read_Reg(0x1B, &config);
printf("GYRO_CONFIG = 0x%02X\r\n", config);  // 应为0x18

// 3. 打印原始数据
printf("Raw: %d, %d, %d\r\n", raw.accel_x, raw.accel_y, raw.accel_z);
```

### 问题3：任务卡死

**现象**：
- 串口无输出
- LED不闪烁
- 系统无响应

**可能原因**：
1. 互斥锁死锁
2. IIC通信超时未处理
3. 栈溢出

**解决方法**：
```c
// 1. 检查互斥锁配对
OSMutexPend(&IIC_Mutex, ...);
// ... 操作 ...
OSMutexPost(&IIC_Mutex, ...);  // 确保每次Pend都有Post

// 2. 添加超时处理
if(IIC_Wait_Ack())
{
    IIC_Stop();  // 超时时停止IIC
    return 1;
}

// 3. 增加任务栈大小
#define MPU6050_READ_STK_SIZE   2048  // 从1024增加到2048
```

### 问题4：数据更新不及时

**现象**：
- LCD显示延迟
- 数据跳变

**可能原因**：
1. 任务优先级不合理
2. 读取周期太长
3. LCD刷新太慢

**解决方法**：
```c
// 1. 调整任务优先级
#define MPU6050_READ_PRIO    8   // 提高优先级（原来是10）
#define LCD_DISPLAY_PRIO     20  // 降低优先级（原来是15）

// 2. 缩短读取周期
OSTimeDly(5, OS_OPT_TIME_DLY, &err);  // 从10ms改为5ms

// 3. 只刷新变化的部分
if(fabs(new_roll - old_roll) > 0.5f)  // 变化超过0.5°才刷新
{
    LCD_ShowString(...);
    old_roll = new_roll;
}
```

### 问题5：浮点运算导致性能下降

**现象**：
- 任务执行时间过长
- CPU占用率高

**解决方法**：
```c
// 使用定点运算代替浮点运算
typedef struct
{
    int32_t accel_x;  // 单位：0.001g
    int32_t accel_y;
    int32_t accel_z;
} MPU6050_FixedData_t;

// 转换函数
void MPU6050_Process_Data_Fixed(MPU6050_RawData_t *raw, MPU6050_FixedData_t *data)
{
    // accel_x (g) = raw / 16384
    // accel_x (0.001g) = raw * 1000 / 16384 = raw * 125 / 2048
    data->accel_x = (raw->accel_x * 125) / 2048;
    data->accel_y = (raw->accel_y * 125) / 2048;
    data->accel_z = (raw->accel_z * 125) / 2048;
}
```

---

## 总结

### 移植核心要点

1. **延时替换**：`delay_ms()` → `OSTimeDly()`
2. **互斥保护**：共享资源使用互斥锁
3. **任务化设计**：初始化、读取、处理分离
4. **错误处理**：所有函数返回错误码
5. **优先级设计**：读取 > 处理 > 显示

### 推荐的开发流程

1. **第一步**：移植IIC驱动，测试通信
2. **第二步**：移植MPU6050初始化，验证WHO_AM_I
3. **第三步**：实现数据读取任务
4. **第四步**：实现数据显示任务
5. **第五步**：优化性能和稳定性

### 文件清单

```
study/
├── iic_rtos_guide.c        # IIC驱动（RTOS版本）
├── mpu6050_rtos.c          # MPU6050驱动（RTOS版本）
└── 移植指南.md             # 本文档
```

---

**文档结束**
